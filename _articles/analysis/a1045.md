<!--
2021-03-29 00:23:37 +0800
monotonic sub-list
-->

这道题的大意即给出了一组颜色的排序，在一长串颜色中按该顺序选取其中一个子数列。

其实，颜色的数字大小并无意义，如果将所给颜色重新映射为颜色的排名，对于题目的例子，即`2->5, 3->4, 1->3, 5->2, 6->1, 4->0`（不在喜爱颜色里的，如4，就映射为0），那么相当于**在一个数组里找出最长非递减子列**。上面这句话是最重要的，是最重要的，是最重要的。

我比较笨，好长时间都想不出一个快速的方法，终于一天开窍了。这个思路是一遍过的，随时得到目前已读数据的最终解，空间复杂度O(N)，时间复杂度O(LN)。

打了很多字，感觉还是说的少一点，更容易理解，所以一句话：

**截至某个元素的最长非递减子列长度，等于它之前截至排名更高的任何颜色（注意不是任何元素）的最长非递减子列长度+1。**

伪代码：

- 读取N和M个喜爱颜色，排序
- 初始化截止于每一个颜色的最长非递减子列长度为0
- 读取L个颜色，对每一个颜色
  - 遍历排名高于或等于该颜色的所有颜色，找出子列长度的最大值
  - 将该颜色的最长子列长度更新为上述最长长度+1
- 遍历所有颜色，输出子列最长者
